// 遍历原列表的查找过程中，如果当前的比队列的最后一个大，直接插入队列
// 如果当前的比队列中的最后一个小，则通过二分查找的方式在队列中找到比当前数大的那一项，将其替换掉

// 遍历过程中，如果替换的是队列末尾的数，那么把大的数换做小的肯定更有潜力
// 且根据规则，更换的前提是替换的数比前面的都大，但比末尾的数小，所以保证了队列中从小到大的顺序，以及索引的先后顺序
// 另外因为是替换，所以肯定不影响最终寻找的最长个数，这很好理解
// 如： 1 5 8 -> 1 5 6，显然总个数还是 3，而后者更具潜力

// 如果不仅比最后一位小时，为什么还要利用二分查找去前面找到最初比当前值大的进行替换呢？

// 本次将替换倒数第二位为例：1 6 8 -> 1 4 8（ -> 1 4 5）
// 此时总个数依然未变，它的意义在于
//   1、首先它将 1 4 序列作为可能记录在队列中（因为理论上 1 4 比 1 6 更有潜力）
//   2、另外，如果再插入新的值，根据规则，替换末尾的数要比前面的都大（之前是 6，现在是 4），也增加了更多的可能性
//   （假设后续插入的是 5，如果没有将之前的 6 替换为 4，那么得不到 1 4 5 这个序列）
//   而现在得到的 1 4 5 同样是 3 位，但比之前的 1 6 8 要更具潜力，且列表中保证了从小到大的顺序，以及索引的先后顺序

// 在成长为和当前总计个数相当之前，潜力只能是潜力，无法替代最初的统计，最长序列还会按之前的走！

// 再以替换倒数第四位为例：1 3 5 7 9 - > 1 2 5 7 9
// 同理可得到：
//   1、找到的总数不会改变，且新增为以 1 2 为序列的可能性，相比 1 3 更具潜力
//   2、如果后续增加的值都比 3 大，那么根据规则在 5 7 9 都被置换前 3 并不会生效，可以结合以下方式理解
//   2-1、增加新的个数时要求插入的值要比现有的值都大，而其后面总有更大的值
//   2-2、以 1 2 开头的序列虽然更具潜力，但该序列目前只有 2 个，如果后续没有值来延续这个队列，那么最长的还是之前的序列
//   2-3、如果后续出现了几个更小的数（但大于3），把后面的几位替代了，说明以 1 2 为开头的序列追齐了之前的队列
//   那么 1 2 为开头的序列不仅个数达到了目前最高，且更具潜力，后续就会以此序列接着往下寻找
//   3、如果过程中有出现了一个更大的数，但是没有替换完整个呢？如：1 2 5 7 9 -> 1 2 5 6 9
//   3-1、同理现在增加的其实是以 1 3 5 6 开头的序列的可能性
//   （虽然还有 1 2 6，但是少了中间的 5，后续增加两个序列都会增加，所以以 1 2 6 开头的序列拥有不会成为最长的）
//   3-2、如果 6 后面的值没有出现新的值进行替换它也会终究是个潜力，而一旦替换就会成就更小的更具潜力的新序列
//   4、类似的，如果出现更小的值，也是相对于最初最长的序列来看，当其替换位置的后续值都被替换时就是出头之时

export function getSequence(arr) {
  const len = arr.length;
  const result = [0]; // 数组中的元素表示的是索引，默认包含 0 是将第一项作为基准和后续的值进行比较
  const p = arr.slice(0); // 用来存储索引
  //
  let start;
  let end;
  let middle;

  for (let i = 0; i < len; i++) {
    const value = arr[i];

    if (value !== 0) {
      const lastIndex = result[result.length - 1];

      if (value > arr[lastIndex]) {
        p[i] = lastIndex; // 记录它的前一项
        result.push(i);
        continue;
      }

      start = 0;
      end = result.length - 1;

      while (start < end) {
        middle = ((start + end) / 2) | 0; // 中间位置的前一位

        if (value > arr[result[middle]]) {
          start = middle + 1;
        } else {
          end = middle;
        }
      }

      if (value < arr[result[start]]) {
        if (start > 0) {
          // 如果替换的角色不是首位就记住它要替换的前一位
          p[i] = result[start - 1];
        }

        result[start] = i;
      }
    }
  }

  const resLen = result.length;
  let last = result[resLen - 1];
  let resStart = resLen;

  // 从最后一个值开始根据前驱节点向前查找
  while (resStart-- > 0) {
    result[resStart] = last;
    last = p[last]; // 记录的是它前面的索引
  }

  return result;
}

function isEqual(arr1, arr2) {
  return arr1.every((item, i) => item === arr2[i]);
}

// console.log(isEqual(getSequence([5, 3, 4, 0]), [1, 2]));
// console.log(
//   isEqual(getSequence([2, 3, 1, 5, 6, 8, 7, 9, 4]), [0, 1, 3, 4, 6, 7])
// );
